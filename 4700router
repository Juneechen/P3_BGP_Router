#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math
from MessageHandler import MessageHandler
import utils
from copy import deepcopy

class Router:
    ''' 
    Class to represent the router
    '''
    relations = {}
    sockets = {}
    ports = {}
    cache = [] # list of dictionaries, each is a routing announcement
    routing_table = {} # { 'dest network': { localpref : 100, ...  } }

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        self.message_handler = MessageHandler(self)

        for relationship in connections:
            port, neighbor, relation = relationship.split('-')

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor, json.dumps({ 'type': 'handshake', 'src': self.our_addr(neighbor), 'dst': neighbor, 'msg': {}  }))

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return '%d.%d.%d.%d' % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network])) #Shujun's

    def sendJson(self, network, message):
        self.sockets[network].sendto(json.dumps(message).encode('utf-8'), ('localhost', self.ports[network])) #modified

    def cache_update(self, update_msg: dict, srcif):
        ''' Cache the update message
        '''
        # print('CACHING', update_msg)
        cache_msg = deepcopy(update_msg)
        cache_msg['msg']['peer'] = srcif

        self.cache.append(cache_msg)

    def update_table(self, msg: dict, srcif):
        '''       
        msg from srcif: {
                "network": "172.168.0.0",
                "netmask": "255.255.0.0",
                "localpref": 100,
                "ASPath": [2],
                "origin": "EGP",
                "selfOrigin": true
            },
        add key nexthop = srcif
        '''
        # TODO: turn router table into a graph and apply dijkstra to update?

        network = msg['network']
        copy = deepcopy(msg)
        copy['nexthop'] = srcif
        # TODO: verify whether to append our router to the ASPath or not

        if not network in self.routing_table:
            self.routing_table[network] = copy
        else:
            if msg['localpref'] > self.routing_table[network]['localpref'] and True: # TODO: expand update logic?
                self.routing_table[network] = copy



    def get_route(self, dest):
        ''' 
        Find the route to a destination network, return the next hop if exists.
        encoding IP addresses as numbers and using bitwise logic to determine 
        (1) whether two addresses match and 
        (2) the length of the match in bits
        Then, apply rules and longest prefix match to find the next hop
        '''

        matching_routes = []
        # longest_match = 0
        # next_hop = None

        # encoding IP addresses and mask as numbers
        dest_ip_int = utils.parse_ip(dest)

        for network, route in self.routing_table.items():
            network_ip_int = utils.parse_ip(network)
            mask_int = utils.parse_ip(route['netmask'])

            # apply bitwise logic and find all matches, 
            # in case the longest match does not satisfy rules (maybe src is peer and next hope is also peer?)
            if (dest_ip_int & mask_int) == (network_ip_int & mask_int):
                matching_routes.append((network, route, mask_int))
                
                # if mask_int > longest_match:
                #     longest_match = mask_int
                #     next_hop = route['nexthop']

        if not matching_routes:
            return None
        else:
            sorted_routes = sorted(matching_routes, key=utils.custom_sort, reverse=True)
            return sorted_routes[0][1]['nexthop']
    

    def run(self):
        while True:
            # get sockets that are ready for reading, wait for up to 0.1 seconds
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            # read from each ready socket
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                # identify the socket currently being read from
                for sock in self.sockets: 
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break # found
                msg = k.decode('utf-8')

                print("Received message '%s' from %s" % (msg, srcif))

                self.message_handler.handle_message(msg, srcif)
        return
    



if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help='AS number of this router')
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help='connections')
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()
